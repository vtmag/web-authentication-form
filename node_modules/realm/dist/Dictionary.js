"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPOJO = exports.isJsOrRealmDictionary = exports.insertIntoDictionaryOfMixed = exports.createDictionaryAccessor = exports.Dictionary = void 0;
const internal_1 = require("./internal");
/* eslint-disable jsdoc/multiline-blocks -- We need this to have @ts-expect-error located correctly in the .d.ts bundle */
const REALM = Symbol("Dictionary#realm");
const INTERNAL = Symbol("Dictionary#internal");
const DEFAULT_PROPERTY_DESCRIPTOR = { configurable: true, enumerable: true };
const PROXY_HANDLER = {
    get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === "undefined" && typeof prop === "string") {
            return target[internal_1.COLLECTION_ACCESSOR].get(target[INTERNAL], prop);
        }
        else {
            return value;
        }
    },
    set(target, prop, value) {
        if (typeof prop === "string") {
            target[internal_1.COLLECTION_ACCESSOR].set(target[INTERNAL], prop, value);
            return true;
        }
        else {
            (0, internal_1.assert)(typeof prop !== "symbol", "Symbols cannot be used as keys of a dictionary");
            return false;
        }
    },
    deleteProperty(target, prop) {
        // We're intentionally not checking !Reflect.has(target, prop) below to allow deletes to propagate for any key
        if (typeof prop === "string") {
            const internal = target[INTERNAL];
            internal.tryErase(prop);
            // We consider any key without a value as "deletable", the same way `const foo = {}; delete foo.bar;` returns true
            return true;
        }
        else {
            return false;
        }
    },
    ownKeys(target) {
        const internal = target[INTERNAL];
        const result = Reflect.ownKeys(target);
        const keys = internal.keys.snapshot();
        for (let i = 0; i < keys.size(); i++) {
            const key = keys.getAny(i);
            internal_1.assert.string(key, "dictionary key");
            result.push(key);
        }
        return result;
    },
    getOwnPropertyDescriptor(target, prop) {
        const internal = target[INTERNAL];
        if (typeof prop === "string" && internal.contains(prop)) {
            return {
                ...DEFAULT_PROPERTY_DESCRIPTOR,
                get: PROXY_HANDLER.get?.bind(null, target, prop, null),
                set: PROXY_HANDLER.set?.bind(null, target, prop, null),
            };
        }
        else {
            return Reflect.getOwnPropertyDescriptor(target, prop);
        }
    },
};
/**
 * Instances of this class are returned when accessing object properties whose type is `"Dictionary"`
 *
 * Dictionaries behave mostly like a JavaScript object i.e., as a key/value pair
 * where the key is a string.
 */
class Dictionary extends internal_1.Collection {
    /**
     * The representation in the binding.
     * @internal
     */
    [INTERNAL];
    /**
     * Create a `Results` wrapping a set of query `Results` from the binding.
     * @internal
     */
    constructor(realm, internal, accessor, typeHelpers) {
        if (arguments.length === 0 || !(internal instanceof internal_1.binding.Dictionary)) {
            throw new internal_1.IllegalConstructorError("Dictionary");
        }
        super(accessor, typeHelpers, (listener, keyPaths) => {
            return this[INTERNAL].addKeyBasedNotificationCallback(({ deletions, insertions, modifications }) => {
                try {
                    listener(proxied, {
                        deletions: deletions.map((value) => {
                            internal_1.assert.string(value);
                            return value;
                        }),
                        insertions: insertions.map((value) => {
                            internal_1.assert.string(value);
                            return value;
                        }),
                        modifications: modifications.map((value) => {
                            internal_1.assert.string(value);
                            return value;
                        }),
                    });
                }
                catch (err) {
                    // Scheduling a throw on the event loop,
                    // since throwing synchronously here would result in an abort in the calling C++
                    setImmediate(() => {
                        throw err;
                    });
                }
            }, keyPaths ? realm.internal.createKeyPathArray(internal.objectSchema.name, keyPaths) : keyPaths);
        });
        const proxied = new Proxy(this, PROXY_HANDLER);
        Object.defineProperty(this, REALM, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: realm,
        });
        this[INTERNAL] = internal;
        return proxied;
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries Array.prototype.entries}
     * @returns An iterator with all entries in the dictionary.
     */
    *[Symbol.iterator]() {
        yield* this.entries();
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys Array.prototype.keys}
     * @returns An iterator with all values in the dictionary.
     * @since 10.5.0
     * @ts-expect-error We're exposing methods in the end-users namespace of keys */
    *keys() {
        const snapshot = this[INTERNAL].keys.snapshot();
        const size = snapshot.size();
        for (let i = 0; i < size; i++) {
            const key = snapshot.getAny(i);
            internal_1.assert.string(key);
            yield key;
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values Array.prototype.values}
     * @returns An iterator with all values in the dictionary.
     * @since 10.5.0
     * @ts-expect-error We're exposing methods in the end-users namespace of values */
    *values() {
        const realm = this[REALM];
        const values = this[INTERNAL].values;
        const itemType = (0, internal_1.toItemType)(values.type);
        const typeHelpers = this[internal_1.COLLECTION_TYPE_HELPERS];
        const accessor = (0, internal_1.createResultsAccessor)({ realm, typeHelpers, itemType });
        const results = new internal_1.Results(realm, values, accessor, typeHelpers);
        for (const value of results.values()) {
            yield value;
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries Array.prototype.entries}
     * @returns An iterator with all key/value pairs in the dictionary.
     * @since 10.5.0
     * @ts-expect-error We're exposing methods in the end-users namespace of entries */
    *entries() {
        const keys = this[INTERNAL].keys.snapshot();
        const snapshot = this[INTERNAL].values.snapshot();
        const size = keys.size();
        (0, internal_1.assert)(size === snapshot.size(), "Expected keys and values to equal in size");
        const realm = this[REALM];
        const itemType = (0, internal_1.toItemType)(snapshot.type);
        const typeHelpers = this[internal_1.COLLECTION_TYPE_HELPERS];
        const accessor = (0, internal_1.createResultsAccessor)({ realm, typeHelpers, itemType });
        const results = new internal_1.Results(realm, snapshot, accessor, typeHelpers);
        for (let i = 0; i < size; i++) {
            const key = keys.getAny(i);
            const value = results[i];
            yield [key, value];
        }
    }
    /**
     * Checks if this dictionary has not been deleted and is part of a valid Realm.
     * @returns `true` if the dictionary can be safely accessed.
     * @since 0.14.0
     * @ts-expect-error We're exposing methods in the end-users namespace of keys */
    isValid() {
        return this[INTERNAL].isValid;
    }
    /**
     * Adds one or more elements with the specified key and value to the dictionary or updates value if key exists.
     * @param elementsOrKey - The element to add or the key of the element to add.
     * @param value - The value of the element to add.
     * @throws An {@link AssertionError} if not inside a write transaction, if using symbol as keys, or if any value violates type constraints.
     * @returns The dictionary.
     * @since 10.6.0
     */
    set(elementsOrKey, value) {
        internal_1.assert.inTransaction(this[REALM]);
        const elements = typeof elementsOrKey === "object" ? elementsOrKey : { [elementsOrKey]: value };
        (0, internal_1.assert)(Object.getOwnPropertySymbols(elements).length === 0, "Symbols cannot be used as keys of a dictionary");
        for (const [key, value] of Object.entries(elements)) {
            this[key] = value;
        }
        return this;
    }
    /**
     * Removes elements from the dictionary, with the keys provided.
     * This does not throw if the keys are already missing from the dictionary.
     * @param key - The key to be removed.
     * @throws An {@link AssertionError} if not inside a write transaction.
     * @returns The dictionary
     * @since 10.6.0
     * @ts-expect-error We're exposing methods in the end-users namespace of keys */
    remove(key) {
        internal_1.assert.inTransaction(this[REALM]);
        const internal = this[INTERNAL];
        const keys = typeof key === "string" ? [key] : key;
        for (const k of keys) {
            internal.tryErase(k);
        }
        return this;
    }
    /** @internal */
    toJSON(_, cache = new internal_1.JSONCacheMap()) {
        return Object.fromEntries(Object.entries(this).map(([k, v]) => [k, v instanceof internal_1.RealmObject ? v.toJSON(k, cache) : v]));
    }
}
exports.Dictionary = Dictionary;
/** @internal */
function createDictionaryAccessor(options) {
    return options.itemType === 9 /* binding.PropertyType.Mixed */
        ? createDictionaryAccessorForMixed(options)
        : createDictionaryAccessorForKnownType(options);
}
exports.createDictionaryAccessor = createDictionaryAccessor;
function createDictionaryAccessorForMixed({ realm, typeHelpers, }) {
    const { toBinding, fromBinding } = typeHelpers;
    return {
        get(dictionary, key) {
            const value = dictionary.tryGetAny(key);
            switch (value) {
                case internal_1.binding.ListSentinel: {
                    const accessor = (0, internal_1.createListAccessor)({ realm, itemType: 9 /* binding.PropertyType.Mixed */, typeHelpers });
                    return new internal_1.List(realm, dictionary.getList(key), accessor, typeHelpers);
                }
                case internal_1.binding.DictionarySentinel: {
                    const accessor = createDictionaryAccessor({ realm, itemType: 9 /* binding.PropertyType.Mixed */, typeHelpers });
                    return new Dictionary(realm, dictionary.getDictionary(key), accessor, typeHelpers);
                }
                default:
                    return fromBinding(value);
            }
        },
        set(dictionary, key, value) {
            internal_1.assert.inTransaction(realm);
            if ((0, internal_1.isJsOrRealmList)(value)) {
                dictionary.insertCollection(key, 19 /* binding.CollectionType.List */);
                (0, internal_1.insertIntoListOfMixed)(value, dictionary.getList(key), toBinding);
            }
            else if (isJsOrRealmDictionary(value)) {
                dictionary.insertCollection(key, 21 /* binding.CollectionType.Dictionary */);
                insertIntoDictionaryOfMixed(value, dictionary.getDictionary(key), toBinding);
            }
            else {
                dictionary.insertAny(key, toBinding(value));
            }
        },
    };
}
function createDictionaryAccessorForKnownType({ realm, typeHelpers, isEmbedded, }) {
    const { fromBinding, toBinding } = typeHelpers;
    return {
        get(dictionary, key) {
            return fromBinding(dictionary.tryGetAny(key));
        },
        set(dictionary, key, value) {
            internal_1.assert.inTransaction(realm);
            if (isEmbedded) {
                toBinding(value, { createObj: () => [dictionary.insertEmbedded(key), true] });
            }
            else {
                dictionary.insertAny(key, toBinding(value));
            }
        },
    };
}
/** @internal */
function insertIntoDictionaryOfMixed(dictionary, internal, toBinding) {
    // TODO: Solve the "removeAll()" case for self-assignment (https://github.com/realm/realm-core/issues/7422).
    internal.removeAll();
    for (const key in dictionary) {
        const value = dictionary[key];
        if ((0, internal_1.isJsOrRealmList)(value)) {
            internal.insertCollection(key, 19 /* binding.CollectionType.List */);
            (0, internal_1.insertIntoListOfMixed)(value, internal.getList(key), toBinding);
        }
        else if (isJsOrRealmDictionary(value)) {
            internal.insertCollection(key, 21 /* binding.CollectionType.Dictionary */);
            insertIntoDictionaryOfMixed(value, internal.getDictionary(key), toBinding);
        }
        else {
            internal.insertAny(key, toBinding(value));
        }
    }
}
exports.insertIntoDictionaryOfMixed = insertIntoDictionaryOfMixed;
/** @internal */
function isJsOrRealmDictionary(value) {
    return isPOJO(value) || value instanceof Dictionary;
}
exports.isJsOrRealmDictionary = isJsOrRealmDictionary;
/** @internal */
function isPOJO(value) {
    return (typeof value === "object" &&
        value !== null &&
        // Lastly check for the absence of a prototype as POJOs
        // can still be created using `Object.create(null)`.
        (value.constructor === Object || !Object.getPrototypeOf(value)));
}
exports.isPOJO = isPOJO;
//# sourceMappingURL=Dictionary.js.map