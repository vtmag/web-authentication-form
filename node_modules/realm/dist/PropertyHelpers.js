"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPropertyHelpers = void 0;
const internal_1 = require("./internal");
const defaultGet = ({ typeHelpers: { fromBinding }, columnKey }) => (obj) => {
    try {
        return fromBinding(obj.getAny(columnKey));
    }
    catch (err) {
        internal_1.assert.isValid(obj);
        throw err;
    }
};
const defaultSet = ({ realm, typeHelpers: { toBinding }, columnKey }) => (obj, value) => {
    internal_1.assert.inTransaction(realm);
    try {
        if (!realm.isInMigration && obj.table.getPrimaryKeyColumn() === columnKey) {
            throw new Error(`Cannot change value of primary key outside migration function`);
        }
        obj.setAny(columnKey, toBinding(value));
    }
    catch (err) {
        internal_1.assert.isValid(obj);
        throw err;
    }
};
function embeddedSet({ typeHelpers: { toBinding }, columnKey }) {
    return (obj, value) => {
        // Asking for the toBinding will create the object and link it to the parent in one operation.
        // Thus, no need to actually set the value on the `obj` unless it's an optional null value.
        const bindingValue = toBinding(value, { createObj: () => [obj.createAndSetLinkedObject(columnKey), true] });
        // No need to destructure `optional` and check that it's `true` in this condition before setting
        // it to null as objects are always optional. The condition is placed after the invocation of
        // `toBinding()` in order to leave the type conversion responsibility to `toBinding()`.
        if (bindingValue === null) {
            obj.setAny(columnKey, bindingValue);
        }
    };
}
const ACCESSOR_FACTORIES = {
    [7 /* binding.PropertyType.Object */](options) {
        const { columnKey, typeHelpers: { fromBinding }, embedded, } = options;
        (0, internal_1.assert)(options.optional, "Objects are always nullable");
        return {
            get(obj) {
                return fromBinding(obj.getLinkedObject(columnKey));
            },
            set: embedded ? embeddedSet(options) : defaultSet(options),
        };
    },
    [8 /* binding.PropertyType.LinkingObjects */]() {
        return {
            get() {
                throw new Error("Getting linking objects happens through Array");
            },
            set() {
                throw new Error("Setting linking objects happens through Array");
            },
        };
    },
    [128 /* binding.PropertyType.Array */]({ realm, type, name, columnKey, objectType, embedded, linkOriginPropertyName, getClassHelpers, optional, }) {
        const realmInternal = realm.internal;
        const itemType = (0, internal_1.toItemType)(type);
        const itemHelpers = (0, internal_1.getTypeHelpers)(itemType, {
            realm,
            name: `element of ${name}`,
            optional,
            getClassHelpers,
            objectType,
            objectSchemaName: undefined,
        });
        if (itemType === 8 /* binding.PropertyType.LinkingObjects */) {
            // Locate the table of the targeted object
            internal_1.assert.string(objectType, "object type");
            (0, internal_1.assert)(objectType !== "", "Expected a non-empty string");
            const targetClassHelpers = getClassHelpers(objectType);
            const { objectSchema: { tableKey, persistedProperties }, } = targetClassHelpers;
            // TODO: Check if we want to match with the `p.name` or `p.publicName` here
            const targetProperty = persistedProperties.find((p) => p.name === linkOriginPropertyName);
            (0, internal_1.assert)(targetProperty, `Expected a '${linkOriginPropertyName}' property on ${objectType}`);
            const tableRef = internal_1.binding.Helpers.getTable(realmInternal, tableKey);
            const resultsAccessor = (0, internal_1.createResultsAccessor)({ realm, typeHelpers: itemHelpers, itemType });
            return {
                get(obj) {
                    const tableView = obj.getBacklinkView(tableRef, targetProperty.columnKey);
                    const results = internal_1.binding.Results.fromTableView(realmInternal, tableView);
                    return new internal_1.Results(realm, results, resultsAccessor, itemHelpers);
                },
                set() {
                    throw new Error("Not supported");
                },
            };
        }
        else {
            const listAccessor = (0, internal_1.createListAccessor)({ realm, typeHelpers: itemHelpers, itemType, isEmbedded: embedded });
            return {
                listAccessor,
                get(obj) {
                    const internal = internal_1.binding.List.make(realm.internal, obj, columnKey);
                    internal_1.assert.instanceOf(internal, internal_1.binding.List);
                    return new internal_1.List(realm, internal, listAccessor, itemHelpers);
                },
                set(obj, values) {
                    internal_1.assert.inTransaction(realm);
                    internal_1.assert.iterable(values);
                    const internal = internal_1.binding.List.make(realm.internal, obj, columnKey);
                    internal.removeAll();
                    let index = 0;
                    try {
                        for (const value of values) {
                            listAccessor.insert(internal, index++, value);
                        }
                    }
                    catch (err) {
                        if (err instanceof internal_1.TypeAssertionError) {
                            err.rename(`${name}[${index - 1}]`);
                        }
                        throw err;
                    }
                },
            };
        }
    },
    [512 /* binding.PropertyType.Dictionary */]({ columnKey, realm, name, type, optional, objectType, getClassHelpers, embedded }) {
        const itemType = (0, internal_1.toItemType)(type);
        const itemHelpers = (0, internal_1.getTypeHelpers)(itemType, {
            realm,
            name: `value in ${name}`,
            getClassHelpers,
            objectType,
            optional,
            objectSchemaName: undefined,
        });
        const dictionaryAccessor = (0, internal_1.createDictionaryAccessor)({
            realm,
            typeHelpers: itemHelpers,
            itemType,
            isEmbedded: embedded,
        });
        return {
            get(obj) {
                const internal = internal_1.binding.Dictionary.make(realm.internal, obj, columnKey);
                return new internal_1.Dictionary(realm, internal, dictionaryAccessor, itemHelpers);
            },
            set(obj, value) {
                internal_1.assert.inTransaction(realm);
                const internal = internal_1.binding.Dictionary.make(realm.internal, obj, columnKey);
                // Clear the dictionary before adding new values
                internal.removeAll();
                internal_1.assert.object(value, `values of ${name}`, { allowArrays: false });
                for (const [k, v] of Object.entries(value)) {
                    try {
                        dictionaryAccessor.set(internal, k, v);
                    }
                    catch (err) {
                        if (err instanceof internal_1.TypeAssertionError) {
                            err.rename(`${name}["${k}"]`);
                        }
                        throw err;
                    }
                }
            },
        };
    },
    [256 /* binding.PropertyType.Set */]({ columnKey, realm, name, type, optional, objectType, getClassHelpers }) {
        const itemType = (0, internal_1.toItemType)(type);
        const itemHelpers = (0, internal_1.getTypeHelpers)(itemType, {
            realm,
            name: `value in ${name}`,
            getClassHelpers,
            objectType,
            optional,
            objectSchemaName: undefined,
        });
        internal_1.assert.string(objectType);
        const setAccessor = (0, internal_1.createSetAccessor)({ realm, typeHelpers: itemHelpers, itemType });
        return {
            get(obj) {
                const internal = internal_1.binding.Set.make(realm.internal, obj, columnKey);
                return new internal_1.RealmSet(realm, internal, setAccessor, itemHelpers);
            },
            set(obj, value) {
                internal_1.assert.inTransaction(realm);
                const internal = internal_1.binding.Set.make(realm.internal, obj, columnKey);
                // Clear the set before adding new values
                internal.removeAll();
                internal_1.assert.array(value, "values");
                for (const v of value) {
                    setAccessor.insert(internal, v);
                }
            },
        };
    },
    [9 /* binding.PropertyType.Mixed */](options) {
        const { realm, columnKey, typeHelpers } = options;
        const { fromBinding, toBinding } = typeHelpers;
        const listAccessor = (0, internal_1.createListAccessor)({ realm, typeHelpers, itemType: 9 /* binding.PropertyType.Mixed */ });
        const dictionaryAccessor = (0, internal_1.createDictionaryAccessor)({ realm, typeHelpers, itemType: 9 /* binding.PropertyType.Mixed */ });
        return {
            get(obj) {
                try {
                    const value = obj.getAny(columnKey);
                    switch (value) {
                        case internal_1.binding.ListSentinel: {
                            const internal = internal_1.binding.List.make(realm.internal, obj, columnKey);
                            return new internal_1.List(realm, internal, listAccessor, typeHelpers);
                        }
                        case internal_1.binding.DictionarySentinel: {
                            const internal = internal_1.binding.Dictionary.make(realm.internal, obj, columnKey);
                            return new internal_1.Dictionary(realm, internal, dictionaryAccessor, typeHelpers);
                        }
                        default:
                            return fromBinding(value);
                    }
                }
                catch (err) {
                    internal_1.assert.isValid(obj);
                    throw err;
                }
            },
            set(obj, value) {
                internal_1.assert.inTransaction(realm);
                if ((0, internal_1.isJsOrRealmList)(value)) {
                    obj.setCollection(columnKey, 19 /* binding.CollectionType.List */);
                    const internal = internal_1.binding.List.make(realm.internal, obj, columnKey);
                    (0, internal_1.insertIntoListOfMixed)(value, internal, toBinding);
                }
                else if ((0, internal_1.isJsOrRealmDictionary)(value)) {
                    obj.setCollection(columnKey, 21 /* binding.CollectionType.Dictionary */);
                    const internal = internal_1.binding.Dictionary.make(realm.internal, obj, columnKey);
                    (0, internal_1.insertIntoDictionaryOfMixed)(value, internal, toBinding);
                }
                else {
                    defaultSet(options)(obj, value);
                }
            },
        };
    },
};
function getPropertyHelpers(type, options) {
    const { typeHelpers, columnKey, embedded, objectType } = options;
    const accessorFactory = ACCESSOR_FACTORIES[type];
    if (accessorFactory) {
        const accessors = accessorFactory(options);
        return { ...accessors, ...typeHelpers, type: options.type, columnKey, embedded, objectType };
    }
    else {
        return {
            get: defaultGet(options),
            set: defaultSet(options),
            ...typeHelpers,
            type: options.type,
            columnKey,
            embedded,
            objectType,
        };
    }
}
/** @internal */
function createPropertyHelpers(property, options) {
    const collectionType = property.type & 896 /* binding.PropertyType.Collection */;
    const typeOptions = {
        realm: options.realm,
        name: property.publicName || property.name,
        getClassHelpers: options.getClassHelpers,
        objectType: property.objectType,
        objectSchemaName: property.objectSchemaName,
        optional: !!(property.type & 64 /* binding.PropertyType.Nullable */),
    };
    if (collectionType) {
        return getPropertyHelpers(collectionType, {
            ...property,
            ...options,
            ...typeOptions,
            typeHelpers: (0, internal_1.getTypeHelpers)(collectionType, typeOptions),
        });
    }
    else {
        const itemType = (0, internal_1.toItemType)(property.type);
        return getPropertyHelpers(itemType, {
            ...property,
            ...options,
            ...typeOptions,
            typeHelpers: (0, internal_1.getTypeHelpers)(itemType, typeOptions),
        });
    }
}
exports.createPropertyHelpers = createPropertyHelpers;
//# sourceMappingURL=PropertyHelpers.js.map